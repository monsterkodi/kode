###
00000000   00000000  000000000  000   000  00000000   000   000  00000000  00000000   
000   000  000          000     000   000  000   000  0000  000  000       000   000  
0000000    0000000      000     000   000  0000000    000 0 000  0000000   0000000    
000   000  000          000     000   000  000   000  000  0000  000       000   000  
000   000  00000000     000      0000000   000   000  000   000  00000000  000   000  
###

print = require './print'

# inserts implicit return statements

class Returner

    @: (@kode) ->

        @verbose = @kode.args.verbose
        @debug   = @kode.args.debug
        
    #  0000000   0000000   000      000      00000000   0000000  000000000  
    # 000       000   000  000      000      000       000          000     
    # 000       000   000  000      000      0000000   000          000     
    # 000       000   000  000      000      000       000          000     
    #  0000000   0000000   0000000  0000000  00000000   0000000     000     
    
    collect: (tl) -> @scope tl

    #  0000000   0000000   0000000   00000000   00000000  
    # 000       000       000   000  000   000  000       
    # 0000000   000       000   000  00000000   0000000   
    #      000  000       000   000  000        000       
    # 0000000    0000000   0000000   000        00000000  
    
    scope: (body) ->

        if body?.exps?.length
            @exp e for e in body.exps
        body
        
    # 00000000  000   000  000   000   0000000  
    # 000       000   000  0000  000  000       
    # 000000    000   000  000 0 000  000       
    # 000       000   000  000  0000  000       
    # 000        0000000   000   000   0000000  
    
    func: (f) ->
        
        @exp f.args if f.args
        
        if f.body?.exps?.length

            if f.name?.text not in ['@' 'constructor']
                
                lst = f.body.exps[-1]
                
                ins = => @insert f.body.exps
                
                if  lst.type in @kode.atoms ➜ ins()
                    lst.call                ➜ if lst.call.callee.text not in ['log' 'warn' 'error'] then ins()
                    lst.operation           ➜ ins()
                    lst.func                ➜ ins()
                    lst.array               ➜ ins()
                    lst.prop                ➜ ins()
                    lst.index               ➜ ins()
                    lst.object              ➜ ins()
                    lst.assert              ➜ ins()
                    lst.stripol             ➜ ins()
                    lst.qmrkop              ➜ ins()
                    lst.incond              ➜ ins()
                    lst.compare             ➜ null
                    lst.return              ➜ null
                    lst.while               ➜ null
                    lst.for                 ➜ null
                    lst.if                  ➜ @if lst.if
                    lst.try                 ➜ @try lst.try
                    lst.switch              ➜ @switch lst.switch
                                            ➜ log 'todo: returner' Object.keys(lst)[0]
            
            @scope f.body 
        
    # 000  00000000  
    # 000  000       
    # 000  000000    
    # 000  000       
    # 000  000       
    
    if: (e) ->
        
        e.returns = true
        @insert e.then
        for ei in e.elifs
            @insert ei.elif.then if ei.elif.then
        
        @insert e.else if e.else

    # 000000000  00000000   000   000  
    #    000     000   000   000 000   
    #    000     0000000      00000    
    #    000     000   000     000     
    #    000     000   000     000     
    
    try: (e) ->
        
        @insert e.exps
        @insert e.finally if e.finally
        
    #  0000000  000   000  000  000000000   0000000  000   000  
    # 000       000 0 000  000     000     000       000   000  
    # 0000000   000000000  000     000     000       000000000  
    #      000  000   000  000     000     000       000   000  
    # 0000000   00     00  000     000      0000000  000   000  
    
    switch: (e) ->
        
        for w in e.whens
            @insert w.when.then if valid w.when.then

        @insert e.else if valid e.else
        
    # 000  000   000   0000000  00000000  00000000   000000000  
    # 000  0000  000  000       000       000   000     000     
    # 000  000 0 000  0000000   0000000   0000000       000     
    # 000  000  0000       000  000       000   000     000     
    # 000  000   000  0000000   00000000  000   000     000     
    
    insert: (e) ->

        if e instanceof Array
            lst = e[-1]
            if lst.if     ➜ return @if lst.if
            if lst.try    ➜ return @try lst.try
            if lst.return ➜ return
            if lst.while  ➜ return
            if lst.for    ➜ return
            
            if not (lst.return or lst.call?.callee?.text in ['log' 'throw'])
                e.push
                    return:
                        ret: type:'keyword' text:'return'
                        val: e.pop()
            
    # 00000000  000   000  00000000   
    # 000        000 000   000   000  
    # 0000000     00000    00000000   
    # 000        000 000   000        
    # 00000000  000   000  000        
    
    exp: (e) ->

        if not e then return
            
        if  
            e.type              ➜ return
            e instanceof Array  ➜ @exp v for v in e if e.length
            e instanceof Object
            
                if e.func
                    @func e.func
                else
                    for key,val of e
                        if val
                            if val.type then @exp val
                            else
                                if val instanceof Array
                                    @exp v for v in val
                                else
                                    @exp v for k,v of val
        
    verb: -> if @verbose then console.log.apply console.log, arguments 

module.exports = Returner
